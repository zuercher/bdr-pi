#!/bin/bash

#/# Usage: imager.sh <command> <options>
#/#
#/# Commands:
#/#     list-disks [--all]
#/#         List available disks for imaging. Defaults to physical,
#/#         external disks. Use the --all flag to see all disks.
#/#
#/#     list-images
#/#         List available images. Defaults to 64-bit OS images.
#/#
#/#     image DISK
#/#         Image the storage device and pre-configure bdr-pi
#/#         installation scripting.
#/#
#/#     clear-cache
#/#         Clear the local cache of images and image detatils.
#/#

set -u
set -o pipefail

#{{include fs.sh}}#
#{{include io.sh}}#
#{{include setup_config.sh}}#

ROOT_DIR="$(cd "$(dirname "$0}")" && pwd)"

DRYRUN="false"

OSLIST_URL="https://downloads.raspberrypi.org/os_list_imagingutility_v4.json"

BDRPI_TMP="${TMPDIR:-/tmp}/bdr-pi-imager.$$"
CACHE_DIR="${HOME}/.bdr-pi-cache"

# print usage and quit
usage() {
    if [[ -n "$1" ]]; then
        perror "$@"
        perror ""
    fi
    grep "^#/#" "$0" | cut -c"5-" >&2
    exit 1
}

# make a file in our temp directory
tmpfile() {
    local name="${BDRPI_TMP}/${1:-tmp}"
    echo "${name}"
}
trap 'rm -rf "${BDRPI_TMP}"' EXIT

# list disks for imaging
list_disks() {
    declare -a TYPES=("external" "physical")

    while [[ -n "${1:-}" ]]; do
        case "$1" in
            -a|-all|--all)
                TYPES=()
                shift
                ;;
            *)
                usage "ERROR: list-disks: unknown flag $1"
                ;;
        esac
    done

    local PLIST="$(tmpfile disk-plist)"
    local TOTAL=0

    diskutil list -plist ${TYPES[@]:-} >"${PLIST}" || abort "error listing disks"

    local NUM_DISKS="$(plutil -extract AllDisksAndPartitions raw "${PLIST}")"
    if [[ "${NUM_DISKS}" -gt 0 ]]; then
        local INDEX
        for INDEX in $(jot "${NUM_DISKS}" 0); do
            local DISK="$( \
                  plutil \
                         -extract "AllDisksAndPartitions.${INDEX}.DeviceIdentifier" \
                         raw "${PLIST}" )"
            if [[ -z "${DISK}" ]]; then
                continue
            fi

            local VOLUME="$( \
                  plutil \
                         -extract "AllDisksAndPartitions.${INDEX}.Partitions.0.MountPoint" \
                         raw "${PLIST}" )"

            echo "/dev/${DISK}  ${VOLUME:-?}"
            let TOTAL=TOTAL+1
        done
    fi

    if [[ "${TOTAL}" -eq 0 ]]; then
        echo "No disks found."
    fi

    return 0
}

# download a resource $1=URL $2=sha256 (or omit for no checks)
download_resource() {
    local IMAGEURL="${1:-}"
    local HASH="${2:-}"

    if [[ -z "${IMAGEURL}" ]]; then
        abort "internal error: no image url"
    fi

    local FILE="$(basename "${IMAGEURL}")"
    local CACHE_FILE="${CACHE_DIR}/${FILE}"

    if [[ -f "${CACHE_FILE}" ]]; then
        echo "using cached file ${CACHE_FILE}" >/dev/stderr
    else
        echo "downloading ${IMAGEURL}" >/dev/stderr

        curl --progress-bar --output "${CACHE_FILE}" "${IMAGEURL}" || \
            abort "failed to download ${IMAGEURL}"
    fi

    if [[ -n "${HASH}" ]]; then
        echo "validating file..." >/dev/stderr

        local FILE="$(prep_image "${CACHE_FILE}")"
        local FILEHASH="$(shasum -a 256 "${FILE}" | awk '{print $1}')"

        [[ "${FILEHASH}" == "${HASH}" ]] || abort "hash mismatch got ${FILEHASH}, expected ${HASH}"

        echo "ok" >/dev/stderr
    fi

    echo "${CACHE_FILE}"
}

# get a list of images via OSLIST_URL
get_images() {
    local OSLIST
    OSLIST="$(tmpfile oslist-json)"

    local FILTERED_OSLIST="$(tmpfile oslist-filtered-json)"

    # Get the top-level images.
    {
        jq '.os_list' "${OSLIST}" | \
            jq '.[] | select(.devices // [] | contains(["pi4-64bit"])) | {"name":.name, "url":.url, "sha":.extract_sha256}' | \
            jq 'select(.url != null)' >"${FILTERED_OSLIST}"
    } || abort "failed to perform first filter pass on os list"

    # Get nested images.
    {
        jq '.os_list' "${OSLIST}" | \
            jq '.[] | (.subitems // [])[] | select(.devices // [] | contains(["pi4-64bit"])) | {"name":.name, "url":.url, "sha":.extract_sha256}' | \
            jq 'select(.url != null)' >>"${FILTERED_OSLIST}"
    } || abort "failed to perform second filter pass on os list"

    echo "${FILTERED_OSLIST}"
}

# print a list of images
list_images() {
    local IMAGELIST="$(get_images "$@")"

    jq -r '.name + "\n\t" + .url + "\n"' "${IMAGELIST}"

    return 0
}

# if the file is compressed, decompress it and return a path to the decompressed file,
# otherwise just returns the file
prep_image() {
    IMAGE="${1}"

    if [[ "${IMAGE}" = *.xz ]]; then
        local BASE="$(basename "${IMAGE}")"
        local RESULT="$(tmpfile "${BASE/%\.xz/}")"
        if [[ ! -f "${RESULT}" ]]; then
            xz --decompress --stdout --thread=2 "${IMAGE}" > "${RESULT}"
        fi
        echo "${RESULT}"
    else
        echo "${IMAGE}"
    fi
}

# prompt the user to select an image to use
select_image() {
    local IMAGELIST="$(get_images "$@")"

    jq -r '.name' "${IMAGELIST}" | nl -s $'.\t'

    local DEFAULT="$(
        jq -r '.name' "${IMAGELIST}" | \
        nl -s: -w1 | \
        grep Legacy | grep 64-bit | grep Lite |\
        cut -d: -f1)"

    local PICK
    if [[ -n "${DEFAULT}" ]]; then
        PICK="$(prompt_default "${DEFAULT}" "Select a base image:")"
    else
        PICK="$(prompt "Select a base image:")"
    fi
    [[ -n "${PICK}" ]] || abort "no image selected"

    local IMAGEURL="$(
        jq -r '.url' "${IMAGELIST}" | \
        nl -s: -w1 | \
        grep -E "^${PICK}:" |\
        cut -d: -f2-)"
    [[ -n "${IMAGEURL}" ]] || abort "no valid image selected"

    local IMAGEHASH="$(
        jq -r '.sha' "${IMAGELIST}" | \
        nl -s: -w1 | \
        grep -E "^${PICK}:" |\
        cut -d: -f2-)"

    local IMAGE="$(download_resource "${IMAGEURL}" "${IMAGEHASH}")"

    echo "${IMAGE}"
}

# query use about configuring wifi
set_wifi_confg() {
    local FIRST=true
    local ADD_WIFI
    while true; do
        echo >/dev/stderr

        if "${FIRST}"; then
            ADD_WIFI="$(prompt_yesno "Pre-configure wifi for post-boot configuration?")"
            FIRST=false
        else
            ADD_WIFI="$(prompt_yesno "Pre-configure another wifi network?")"
        fi

        if [[ "${ADD_WIFI}" != "Y" ]]; then
            break
        fi

        SSID="$(prompt "Enter an SSID:")"
        PASS="$(prompt_pw "Enter a password for ${SSID}:")"

        [[ -n "${SSID}" ]] && [[ -n "${PASS}" ]] || abort "network config requires both an SSID and password"

        set_setup_config_array WIFI_SSID append "${SSID}"
        set_setup_config_array WIFI_PASS append "${PASS}"
    done

    echo >/dev/stderr

    ADD_WIFI="$(prompt_yesno "Prompt for additional networks during post-boot configuration?")"
    if [[ "${ADD_WIFI}" == "Y" ]]; then
        set_setup_config WIFI_PERFORM_SSID_SETUP "true"
    else
        set_setup_config WIFI_PERFORM_SSID_SETUP "false"
    fi
}

set_lifepo4wered_config() {
    local CONFIG_LIFEPO

    CONFIG_LIFEPO="$(prompt_yesno "Configure lifepo4wered-pi UPS software during post-boot configuration?")"
    if [[ "${CONFIG_LIFEPO}" == "Y" ]]; then
        set_setup_config LIFEPO_PERFORM_SETUP="true"
    else
        set_setup_config LIFEPO_PERFORM_SETUP="false"
    fi
}

# prepare and write an image to the given $1=disk
image() {
    local DISK="${1:-}"
    if [[ -z "${DISK}" ]]; then
        usage "ERROR: image: missing disk name argument"
    fi

    local SAFE=""
    if "${DRYRUN}"; then
        echo "Dry-run mode enabled."
        SAFE="echo"
    fi

    local IMAGE="$(select_image)"

    local PLIST="$(tmpfile disk-plist)"
    diskutil info -plist "${DISK}" >"${PLIST}" || abort "error getting disk info"

    local SIZE="$(plutil -extract "Size" raw "${PLIST}")"
    if [[ -z "${SIZE}" ]]; then
        abort "failed to determine disk size"
    fi
    if [[ "${SIZE}" -lt 32000000000 ]]; then
        abort "volume is less than 32 GiB... giving up"
    fi
    local SIZE_GB
    let SIZE_GB=(SIZE / 1000000000)

    echo "Volume size is approximately ${SIZE_GB} GiB (${SIZE})."

    local BLOCKSIZE="$(plutil -extract "DeviceBlockSize" raw "${PLIST}")"
    if [[ -z "${BLOCKSIZE}" ]] || [[ "${BLOCKSIZE}" -eq 0 ]]; then
        abort "cannot determine block size"
    fi
    echo "Block size is ${BLOCKSIZE}."

    # rewrite /dev/diskX to /dev/rdiskX
    RDISK="${DISK//\/dev\/disk//dev/rdisk}"

    # format the disk
    ${SAFE} sudo diskutil eraseDisk FAT32 "BDR_PI" MBRFormat "${DISK}" || \
        abort "format operation failed"

    # unmount the disk
    ${SAFE} diskutil unmountDisk "${DISK}" || abort "failed to unmount disk"

    # zero first MB
    let NBLKS=(1024*1024 / BLOCKSIZE)
    ${SAFE} sudo dd bs="${BLOCKSIZE}" count="${NBLKS}" \
            if=/dev/zero \
            of="${RDISK}" \
            status=none || abort "failed to zero first MB"

    # zero last MB
    let SIZE_BLKS=(SIZE / 512)
    let SBLKS=(SIZE_BLKS - NBLKS)
    ${SAFE} sudo dd bs="${BLOCKSIZE}" oseek="${SBLKS}" count="${NBLKS}" \
            if=/dev/zero \
            of="${RDISK}" \
            status=none || abort "failed to zero last MB"


    echo
    echo "Writing image to disk... this could take a while..."

    # Write the image. rpi-imager skips the first 4kb and then writes
    # it last. Not sure why.
    ${SAFE} sudo dd bs=1m if="$(prep_image "${IMAGE}")" of="${RDISK}" status=progress

    echo "...done"

    # remount the disk
    ${SAFE} diskutil mountDisk "${DISK}" || abort "failed to re-mount disk"

    local VOLUME
    if "${DRYRUN}"; then
        # Pretend /tmp is our volume.
        VOLUME="/tmp/example-boot-volume"
        mkdir -p "${VOLUME}" || abort "error creating ${VOLUME} for dry-run"
    else
        # Figure out the volume name of our disk (which is set by the image), and where it lives
        VOLUME="$(list_disks | grep -F "${DISK}" | awk '{print $1}')"

        [[ -n "${VOLUME}" ]] || abort "could not find volume for ${DISK}"
    fi

    export BDRPI_SETUP_CONFIG_FILE="${VOLUME}/bdrpi-config.txt"
    echo "Writing setup config to ${BDRPI_SETUP_CONFIG_FILE}"

    set_wifi_config
    set_lifepo4wered_config

    cp "${ROOT_DIR}/resources/firstrun.sh" "${VOLUME}/bdrpi-firstrun.sh"
    cp "${ROOT_DIR}/docs/setup.sh" "${VOLUME}/bdrpi-setup.sh"

    if [[ -f "${VOLUME}/cmdline.txt" ]]; then
        local CMDLINE="$(cat "${VOLUME}/cmdline.txt")"
        CMDLINE="${CMDLINE} systemd.run=/boot/bdrpi-firstrun.sh systemd.run_success_action=reboot systemd.unit=kernel-command-line.target"
        ${SAFE} echo "${CMDLINE}" >"${VOLUME}/cmdline.txt" || abort "unable to write ${VOLUME}/cmdline.txt"
    fi

    echo "Ejecting ${DISK}..."

    ${SAFE} diskutil "${DISK}" || abort "failed to eject ${DISK}, but I think I'm done..."

    echo "Done!"

    return 0
}

clear_cache() {
    local SAFE=""
    if "${DRYRUN}"; then
        echo "Dry-run mode enabled."
        SAFE="echo"
    fi

    ${SAFE} rm -rf "${CACHE_DIR}"
}

# Require bash
# shellcheck disable=SC2292
if [ -z "${BASH_VERSION:-}" ]; then
    abort "bash is required to interpret this script."
fi

# Currently we only support macOS for imaging SD cards.
OS="$(uname)"
if [[ "$OS" != "Darwin" ]]; then
    abort "OS is ${OS} -- this isn't going to work out."
fi

# These should just exist on macOS
for TOOL in awk curl diskutil jot plutil shasum; do
    if ! installed "${TOOL}"; then
        abort "could not find ${TOOL}, is this macOS?"
    fi
done

for TOOL in jq xz; do
    if ! installed "${TOOL}"; then
        abort "could not find ${TOOL}, please install (homebrew works)"
    fi
done

mkdir -p "${BDRPI_TMP}" || abort "failed to create temp dir"
mkdir -p "${CACHE_DIR}" || abort "failed to create image cache dir"

while [[ -n "${1:-}" ]]; do
    case "$1" in
        -n|-dry-run|--dry-run)
            DRYRUN=true
            shift
            ;;

        clear-cache)
            shift
            clear_cache "$@"
            exit $?
            ;;

        list-disks)
            shift
            list_disks "$@"
            exit $?
            ;;

        list-images)
            shift
            list_images "$@"
            exit $?
            ;;

        image)
            shift
            image "$@"
            exit $?
            ;;
        *)
            usage "ERROR: unknown command: $1"
            ;;
    esac
done

usage "ERROR: no command given"
